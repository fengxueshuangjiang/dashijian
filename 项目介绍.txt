项目：
  大事件
技术：
  运用了HTML，css，js，jQuery相关技术和ES6部分语法，用到了layui组件库，Echarts数据可视化图表库,模板引擎插件，cropper插件，以及Ajax技术来完成数据交互
开发模式:
  前后端分离
功能：
  用户可以注册账号和设置密码，然后通过注册的账号密码进行登录，用户还可以设置自己的头像以及个人基本信息；该网站主要用来发布文章以及查阅别人的文章，可以在文章类别管理界面添加类别，还可以在文章列表界面对文章进行删改查操作，然后再发布文章界面可以根据标题和类别发布自己想发布的文章
项目介绍:
  1.首先是login登录页面，首先用html和css做基本布局，然后用layui组件进行登录框和注册框布局，然后先将注册的盒子进行隐藏，当点击去注册时，隐藏登录界面显示注册界面，当再点击去登陆时隐藏注册界面显示登录界面，然后在输入用户名和密码时进行规则的验证，在js中定义了一系列验证规则，然后监听表单的提交事件，首先阻止提交的默认转跳行为，然后拿到用户输入的注册或登录界面信息，然后发送post请求将输入的信息传给后台，保存到数据库，当登录成功时，会向浏览器的存储空间存储一个token字符串，用来做用户身份的验证
  2.然后创建一个baseAPI.js的文件，进行Ajax路径的拼接，然后再定义访问带/my/字符串的网页时加入token请求头，来进行用户身份验证
  3.然后是index页面，先用HTML加css完成基本布局，然后用layui组件加载出菜单框，然后对在菜单框上进行调整，然后定义出一个div容器，这个容器将加载后续的主页以及个人信息，文章操作等html页面，然后通过iframe标签进行占位，在a链接跳转页面时加入target属性，此时跳转的页面就会在该容器中显示，布局完成好之后，在js中发送Ajax的get请求，获取用户的个人信息，然后再HTML页面中定义头像部分以及欢迎文字，头像有两个方案，一个是用户没有头像时，会加载用户名或昵称的首个字母或汉字来当做头像，此时另一个头像部分会被隐藏，当用户有头像时则加载用户头像，字母头像部分将被隐藏，然后我们在js中对获取来的数据信息进行验证，当头像为空则加载字符头像，当头像不为空则加载真正的头像，同时，将用户的用户名和昵称渲染在相应的地方，然后是退出按钮，监听该按钮的点击时间当点击被触发，则弹出提示框，点击取消则不进行任何操作，若点击确定，则执行提示框中的回调函数，此时将清除localstorage中存储的token字符串，同时返回登录界面
  4.然后是首页，dashboard.html中，定义若干个容器，然后通过echarts数据可视化图表库将相应的可视化图表加载到该容器中，然后在JavaScript的标签中定义我们所需要的数据，然后当在index页面中点击首页选项，相应的超链接会跳到首页的html，因为我们设置了target，所以会在我们刚才定义的容器中显示首页,然后通过layui-this设置首页为默认点击.
  5.然后是个人中心板块，该板块分为三部分，为基本资料，更改头像，重置密码三个页面;
    ①.首先是基本资料页面，通过HTML和css对页面布局，然后通过layui组件，渲染表单部分，然后在js文件中定义昵称验证规则，然后发送Ajax的get请求，根据token查询相应的用户信息，然后调用layui的form.val事件，将查询过来的数据根据name自动渲染在设置了lay-filter的表单中，然后监听重置按扭的点击，点击重置鸟则，重新调用获取用户信息的方法并渲染form表单方法，然后。用户可以对基本资料中的昵称和邮箱进行修改，登录名称是不可以修改的，因为在input中设置了readonly，然后监听表单提交事件，当用户点击了提交修改，那么我们就发送Ajax请求，将用户在input中输入的内容获取当做数据进行数据提交，然后通过window.parent.userinfos调用父级的方法重新渲染主页的相关信息
    ②.然后是重置密码页面，通过HTML和css对页面布局，然后通过layui组件，渲染表单部分，然后在js中定义验证规则，在定义再次输入密码的表单验证时要注意，该值不能和原密码相同还要和新密码一致，然后发送Ajax的post请求，将。获取的表单值作为数据进行提交，从而对密码进行修改，如果成功了调用reset方法清空表单数据
    ③.最后是设置用户头像页面，通过HTML和css对页面布局，再通过cropper插件，渲染出基本布局结构,然后在js中，获取裁剪区域的Dom元素，然后配置裁剪头像的比例为1，然后通过cropper方法创建出裁剪区域，然后设置文件上传input元素，然后将该元素隐藏，然后监听上传文件点击事件，当点击了该按钮时，实际上是触发文件上传表单的点击事件，此时通过e.target.files[0]拿到用户选择的文件，然后通过URL.createObjectURL方法，将文件转黑路径，然后重新初始化裁剪区，然后监听确定按钮的点击事件，然后创建一个canvas画布，通过toDataURL方法，将画布上的内容转换为base 64格式的字符串，然后发送Ajax的post请求，将该图片上传到数据库，然后通过window.parent.userinfos调用父级的方法重新渲染主页的相关信息
  6.然后是事件管理板块，该板块分为三部分，为事件类别,事件列表,发布文章三个页面;
    ①.首先是事件类别页面，通过HTML和css对页面布局，然后通过layui组件，渲染表单部分，然后在html中定义三个模板，然后在js中，发送Ajax的get请求，拿到文章分类的信息，然后使用template方法和html方法，将拿到的数据渲染到HTML的第一个模板上，然后在监听添加文章按钮的点击事件，当点击了添加文章时，通过layui.open方法，显示一个弹出层，然后设置弹出层的标题内容类型以及大小，然后在监听弹出层中的确认添加点击事件，等点击了确认添加之后，然后获取表单中的数据，然后发送Ajax的post请求，将文章分类的名称和别名添加到数据库，然后通过layui.layer.close方法关闭弹出层，然后再次调用加载文章名称的方法，将页面进行重新渲染；渲染模板引擎的时候，给编辑按钮和删除按钮自定义一个属相，让它的值等于该条数据的ID，然后监听这个编辑按钮的点击事件，当触发了点击时间时通过layui.open方法，显示一个弹出层，然后设置弹出层的标题内容类型以及大小，然后发送Ajax的get请求，通过获取按钮中自定义属性的值，来当做数据的ID对数据进行查找，然后调用layui.form.val方法，把查询到的数据渲染在相应的位置，然后这两个input框中的值可以修改的然后监听该弹出层的确认修改按钮，当点击了确认修改则发送Ajax的post请求，将input框中的值发送给数据库来更改该条数据，然后关闭该弹出层并且调用加载文章名称的方法对页面进行重新渲染；然后在监听删除按钮的点击事件，当点击了删除后，会弹出一个提示框，点击确定之后，则发送Ajax的get请求，将按钮自定义属性的值对应的ID的那条数据删除，然后关闭弹出层，调用方法重新渲染页面
    ②.首先是发布文章页面，通过HTML和css对页面布局，然后通过layui组件，渲染表单部分，然后现在HTML页面中写入一个模板，然后再js中发送Ajax的get请求，获取文章的类别列表，然后将获取过来的数据通过template方法和html方法，渲染到页面的模板中，但是此时下拉列表中不会出现相应的数据需要调用layui.form.render方法来重新加载一下页面，然后初始化图片裁剪器，配置裁剪选项，初始化裁剪区域，然后在HTML页面中写一个input文件上传域。然后监听选择封面按钮的点击事件。当点击事件发生，则实际是触发了文件上传域的点击事件，然后通过e.target.files[0]拿到用户选择的文件，然后通过URL.createObjectURL方法，将文件转黑路径，然后重新初始化裁剪区，然后此时我们有两个按钮，一个是发布，一个是存为草稿，所以我们此时在js中定义一个变量，默认值为发布，如果点击存为草稿这个按钮，则将该状态改为草稿。如果没有点击这个按钮，则状态一直未发布，然后我们监听表单的提交事件，当提交事件触发，先实例化一个FormData对象实例用来获取表单元素的值,然后创建一个canvas画布，通过toDataURL方法，将Canvas画布上的内容，转化为文件对象，将文件对象，存储到fmd中，然后将状态也追加到这个fmd对象上，然后发送Ajax的post请求，将fmd作为数据传入数据库，如果发布文章成功则跳转到世间列表的页面中，来查看自己发布过的文章
    ③.首先是事件列表页面，通过HTML和css对页面布局，然后通过layui组件，渲染表单部分，然后在js中首先定义一个数据，初始。页码值为1，每页显示2条数据，类型和状态都为空，然后发起Ajax的get请求，以刚才定义的数据为请求数据，将获取的数据通过template方法和HTML方法将数据渲染到相应的魔板上，然后再次调用Ajax的get请求，获取到文章的分类，然后通过template和HTML方法将数据渲染到相应的模板上，但是此时必须调layui.form.render方法，重新渲染页面，不然下拉菜单是不会被渲染出来的，然后此时监听筛选按钮的点击事件，当点击事件被触发就获得input的分类和input状态的数据，根据这两个数据，将刚刚定义的数据的类型和状态进行格式化，然后重新调用获取数据的方法，以此来重新渲染页面，然后定义分页的方法，layout的数组，指定了这个分页器的结构，然后配置这个分页器，然后根据分页器这总条数除以每页显示的条数，来显示有几个分页器的模块，然后通过jump对象获取击分页器的元素此时每页显示的条数以及第几页，来调用获取文章信息的方法重新渲染页面数据，注意，此时不能直接调用获取文章数据的方法否则会出现一个死循环，所以我们要判断该jump的方法，是哪种情况下调用的？如果first为真，则是第二种方法调用的，否则是第一种方法调用的，如果是第一种方式调用的话，则触发获取文章信息的方法，然后监听删除按钮的点击事件，此时在HTML页面中在渲染模板引擎的同时，删除按钮被定义了一个自定义属性，值为当前文章的ID值，然后当点击了这个删除按钮时，会出现一个弹出层，询问是否确认删除，当点击确认之后，就会。根据自定义属性中的那个ID值来发起Ajax的get请求用来删除对应ID的那个文章，但此时需要注意有一个bug，当我们处在最后一个分页器时，删除最后一个文章时，我们的页码虽然向前跳了，但是页面的数据并没有重新加载，此时我们要获取该页面上还有几个删除按钮，判断。判断按钮若为1时，页码值减一，但不会小于一，此时我们根据重置的页码值重新调用获取文章信息的方法，重新渲染页面，然后监听查看的点击事件，刚该时间被出发时，获取该按钮上加载模板引擎时所定义的那个自定义属性的ID值，根据这个ID值，发起ajax的get请求，将获取到的数据通过template方法和html方法，渲染道相应的模板引擎上面，来完成对文章详情的查看
